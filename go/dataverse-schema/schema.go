/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package schema

// `InstantiateMsg` is used to initialize a new instance of the dataverse.
type InstantiateMsg struct {
	// A unique name to identify the dataverse instance.
	Name string `json:"name"`
	// The configuration used to instantiate the triple store.
	TriplestoreConfig TripleStoreConfig `json:"triplestore_config"`
}

/*
`ExecuteMsg` defines the set of possible actions that can be performed on the dataverse.

This enum provides variants for registering services, datasets, and other operations related to the dataverse.
*/
type ExecuteMsg struct {
	/*
	   Submits new claims about a resource to the dataverse.

	   The SubmitClaims message is a pivotal component in the dataverse, enabling entities to contribute new claims about various resources. A claim represents a statement made by an entity, referred to as the issuer, which could be a person, organization, or service. These claims pertain to a diverse range of resources, including digital resources, services, zones, or individuals, and are asserted as factual by the issuer.

	   #### Format

	   Claims are injected into the dataverse through Verifiable Credentials (VCs).

	   Primarily, the claims leverage the AXONE ontology, which facilitates articulating assertions about widely acknowledged resources in the dataverse, including digital services, digital resources, zones, governance, and more.

	   Additionally, other schemas may also be employed to supplement and enhance the validated knowledge contributed to these resources.

	   #### Preconditions

	   To maintain integrity and coherence in the dataverse, several preconditions are set for the submission of claims:

	   1. **Format Requirement**: Claims must be encapsulated within Verifiable Credentials (VCs).

	   2. **Unique Identifier Mandate**: Each Verifiable Credential within the dataverse must possess a unique identifier.

	   3. **Issuer Verification**: Claims are accepted if they either: - Bear a verifiable issuer's signature to ensure authenticity. - Originate from the transaction sender, in which case the transaction signature serves as proof of authenticity.

	   4. **Content**: The actual implementation supports the submission of a single Verifiable Credential, containing a single claim.

	   #### Supported cryptographic proofs

	   - `Ed25519Signature2018`

	   - `Ed25519Signature2020`

	   - `EcdsaSecp256k1Signature2019`

	   - `DataIntegrity` with the following cryptosuites: `eddsa-2022`, `eddsa-rdfc-2022`.
	*/
	SubmitClaims *ExecuteMsg_SubmitClaims `json:"submit_claims,omitempty"`
	/*
	   Revoke or withdraw a previously submitted claims.

	   #### Preconditions:

	   1. **Identifier Existence**: The identifier of the claims must exist in the dataverse.
	*/
	RevokeClaims *ExecuteMsg_RevokeClaims `json:"revoke_claims,omitempty"`
}

/*
`QueryMsg` defines the set of possible queries that can be made to retrieve information about the dataverse.

This enum provides variants for querying the dataverse's details and other related information.
*/
type QueryMsg struct {
	// Retrieves information about the current dataverse instance.
	Dataverse *QueryMsg_Dataverse `json:"dataverse,omitempty"`
}

/*
Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.

This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
*/
type Binary string

type QueryMsg_Dataverse struct{}

// DataverseResponse is the response of the Dataverse query.
type DataverseResponse struct {
	// The name of the dataverse.
	Name string `json:"name"`
	// The cognitarium contract address.
	TriplestoreAddress Addr `json:"triplestore_address"`
}

// Contains requested limitations regarding store usages.
type TripleStoreLimitsInput struct {
	// The maximum number of bytes the store can contain. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any. Default to [Uint128::MAX] if not set, which can be considered as no limit.
	MaxByteSize *Uint128 `json:"max_byte_size,omitempty"`
	// The maximum number of bytes an insert data query can contain. Default to [Uint128::MAX] if not set, which can be considered as no limit.
	MaxInsertDataByteSize *Uint128 `json:"max_insert_data_byte_size,omitempty"`
	// The maximum number of triples an insert data query can contain (after parsing). Default to [Uint128::MAX] if not set, which can be considered as no limit.
	MaxInsertDataTripleCount *Uint128 `json:"max_insert_data_triple_count,omitempty"`
	// The maximum limit of a query, i.e. the maximum number of triples returned by a select query. Default to 30 if not set.
	MaxQueryLimit *int `json:"max_query_limit,omitempty"`
	// The maximum number of variables a query can select. Default to 30 if not set.
	MaxQueryVariableCount *int `json:"max_query_variable_count,omitempty"`
	// The maximum number of bytes the store can contain for a single triple. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any. The limit is used to prevent storing very large triples, especially literals. Default to [Uint128::MAX] if not set, which can be considered as no limit.
	MaxTripleByteSize *Uint128 `json:"max_triple_byte_size,omitempty"`
	// The maximum number of triples the store can contain. Default to [Uint128::MAX] if not set, which can be considered as no limit.
	MaxTripleCount *Uint128 `json:"max_triple_count,omitempty"`
}

type ExecuteMsg_RevokeClaims struct {
	// The unique identifier of the claims to be revoked.
	Identifier string `json:"identifier"`
}

/*
A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u64` to get the value out:

``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);

let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
*/
type Uint64 string

type ExecuteMsg_SubmitClaims struct {
	// The Verifiable Credential containing the claims. The claims must be serialized in the format specified by the `format` field.
	Claims Binary `json:"claims"`
	// RDF dataset serialization format for the claims. If not provided, the default format is [N-Quads](https://www.w3.org/TR/n-quads/) format.
	Format *RdfDatasetFormat `json:"format,omitempty"`
}

// Represents the various serialization formats for an RDF dataset, i.e. a collection of RDF graphs ([RDF Dataset](https://www.w3.org/TR/rdf11-concepts/#section-dataset)).
type RdfDatasetFormat string

const (
	/*
	   N-Quads Format

	   N-Quads is an extension of N-Triples to support RDF datasets by adding an optional fourth element to represent the graph name. See the [official N-Quads specification](https://www.w3.org/TR/n-quads/).
	*/
	RdfDatasetFormat_NQuads RdfDatasetFormat = "n_quads"
)

/*
A human readable address.

In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.

This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.

This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
*/
type Addr string

// `TripleStoreConfig` represents the configuration related to the management of the triple store.
type TripleStoreConfig struct {
	// Limitations regarding triple store usage.
	Limits TripleStoreLimitsInput `json:"limits"`
	// The code id that will be used to instantiate the triple store contract in which to store dataverse semantic data. It must implement the cognitarium interface.
	CodeId Uint64 `json:"code_id"`
}

/*
A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u128` to get the value out:

``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);

let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);

let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
*/
type Uint128 string
