{
  "contract_name": "axone-cognitarium",
  "contract_version": "6.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "Instantiate message",
    "type": "object",
    "properties": {
      "limits": {
        "description": "Limitations regarding store usage.",
        "default": {
          "max_byte_size": "340282366920938463463374607431768211455",
          "max_insert_data_byte_size": "340282366920938463463374607431768211455",
          "max_insert_data_triple_count": "340282366920938463463374607431768211455",
          "max_query_limit": 30,
          "max_query_variable_count": 30,
          "max_triple_byte_size": "340282366920938463463374607431768211455",
          "max_triple_count": "340282366920938463463374607431768211455"
        },
        "allOf": [
          {
            "$ref": "#/definitions/StoreLimitsInput"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "StoreLimitsInput": {
        "title": "StoreLimitsInput",
        "description": "Contains requested limitations regarding store usages.",
        "type": "object",
        "properties": {
          "max_byte_size": {
            "description": "The maximum number of bytes the store can contain. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any. Default to [Uint128::MAX] if not set, which can be considered as no limit.",
            "default": "340282366920938463463374607431768211455",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_insert_data_byte_size": {
            "description": "The maximum number of bytes an insert data query can contain. Default to [Uint128::MAX] if not set, which can be considered as no limit.",
            "default": "340282366920938463463374607431768211455",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_insert_data_triple_count": {
            "description": "The maximum number of triples an insert data query can contain (after parsing). Default to [Uint128::MAX] if not set, which can be considered as no limit.",
            "default": "340282366920938463463374607431768211455",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_query_limit": {
            "description": "The maximum limit of a query, i.e. the maximum number of triples returned by a select query. Default to 30 if not set.",
            "default": 30,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "max_query_variable_count": {
            "description": "The maximum number of variables a query can select. Default to 30 if not set.",
            "default": 30,
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "max_triple_byte_size": {
            "description": "The maximum number of bytes the store can contain for a single triple. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any. The limit is used to prevent storing very large triples, especially literals. Default to [Uint128::MAX] if not set, which can be considered as no limit.",
            "default": "340282366920938463463374607431768211455",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_triple_count": {
            "description": "The maximum number of triples the store can contain. Default to [Uint128::MAX] if not set, which can be considered as no limit.",
            "default": "340282366920938463463374607431768211455",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Execute messages",
    "oneOf": [
      {
        "title": "InsertData",
        "description": "Insert the data as RDF triples in the store. For already existing triples it acts as no-op.\n\nOnly the smart contract owner (i.e. the address who instantiated it) is authorized to perform this action.",
        "type": "object",
        "required": [
          "insert_data"
        ],
        "properties": {
          "insert_data": {
            "type": "object",
            "required": [
              "data"
            ],
            "properties": {
              "data": {
                "description": "The data to insert. The data must be serialized in the format specified by the `format` field. And the data are subject to the limitations defined by the `limits` specified at contract instantiation.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  }
                ]
              },
              "format": {
                "description": "The data format in which the triples are serialized. If not provided, the default format is [Turtle](https://www.w3.org/TR/turtle/) format.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/DataFormat"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "title": "DeleteData",
        "description": "Delete the data (RDF triples) from the store matching the patterns defined by the provided query. For non-existing triples it acts as no-op.\n\nExample: ```json { \"prefixes\": [ { \"prefix\": \"foaf\", \"namespace\": \"http://xmlns.com/foaf/0.1/\" } ], \"delete\": [ { \"subject\": { \"variable\": \"s\" }, \"predicate\": { \"variable\": \"p\" }, \"object\": { \"variable\": \"o\" } } ], \"where\": [ { \"simple\": { \"triplePattern\": { \"subject\": { \"variable\": \"s\" }, \"predicate\": { \"namedNode\": {\"prefixed\": \"foaf:givenName\"} }, \"object\": { \"literal\": { \"simple\": \"Myrddin\" } } } } }, { \"simple\": { \"triplePattern\": { \"subject\": { \"variable\": \"s\" }, \"predicate\": { \"variable\": \"p\" }, \"object\": { \"variable\": \"o\" } } } } ] ```\n\nOnly the smart contract owner (i.e. the address who instantiated it) is authorized to perform this action.",
        "type": "object",
        "required": [
          "delete_data"
        ],
        "properties": {
          "delete_data": {
            "type": "object",
            "required": [
              "delete",
              "prefixes",
              "where"
            ],
            "properties": {
              "delete": {
                "description": "Specifies the specific triple templates to delete. If nothing is provided, the patterns from the `where` clause are used for deletion.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/TripleDeleteTemplate"
                }
              },
              "prefixes": {
                "description": "The prefixes used in the operation.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Prefix"
                }
              },
              "where": {
                "description": "Defines the patterns that data (RDF triples) should match in order for it to be considered for deletion.",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/WhereCondition"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "DataFormat": {
        "title": "DataFormat",
        "description": "Represents the format in which the data are serialized, for example when returned by a query or when inserted in the store.",
        "oneOf": [
          {
            "title": "RDF XML",
            "description": "Output in [RDF/XML](https://www.w3.org/TR/rdf-syntax-grammar/) format.",
            "type": "string",
            "enum": [
              "rdf_xml"
            ]
          },
          {
            "title": "Turtle",
            "description": "Output in [Turtle](https://www.w3.org/TR/turtle/) format.",
            "type": "string",
            "enum": [
              "turtle"
            ]
          },
          {
            "title": "N-Triples",
            "description": "Output in [N-Triples](https://www.w3.org/TR/n-triples/) format.",
            "type": "string",
            "enum": [
              "n_triples"
            ]
          },
          {
            "title": "N-Quads",
            "description": "Output in [N-Quads](https://www.w3.org/TR/n-quads/) format.",
            "type": "string",
            "enum": [
              "n_quads"
            ]
          }
        ]
      },
      "IRI": {
        "title": "IRI",
        "description": "Represents an IRI.",
        "oneOf": [
          {
            "title": "Prefixed",
            "description": "An IRI prefixed with a prefix. The prefixed IRI is expanded to a full IRI using the prefix definition specified in the query. For example, the prefixed IRI `rdf:type` is expanded to `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`.",
            "type": "object",
            "required": [
              "prefixed"
            ],
            "properties": {
              "prefixed": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Full",
            "description": "A full IRI.",
            "type": "object",
            "required": [
              "full"
            ],
            "properties": {
              "full": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Literal": {
        "title": "Literal",
        "description": "An RDF [literal](https://www.w3.org/TR/rdf11-concepts/#dfn-literal).",
        "oneOf": [
          {
            "title": "Simple",
            "description": "A [simple literal](https://www.w3.org/TR/rdf11-concepts/#dfn-simple-literal) without datatype or language form.",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "LanguageTaggedString",
            "description": "A [language-tagged string](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)",
            "type": "object",
            "required": [
              "language_tagged_string"
            ],
            "properties": {
              "language_tagged_string": {
                "type": "object",
                "required": [
                  "language",
                  "value"
                ],
                "properties": {
                  "language": {
                    "description": "The [language tag](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tag).",
                    "type": "string"
                  },
                  "value": {
                    "description": "The [lexical form](https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form).",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "title": "TypedValue",
            "description": "A value with a datatype.",
            "type": "object",
            "required": [
              "typed_value"
            ],
            "properties": {
              "typed_value": {
                "type": "object",
                "required": [
                  "datatype",
                  "value"
                ],
                "properties": {
                  "datatype": {
                    "description": "The [datatype IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri).",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IRI"
                      }
                    ]
                  },
                  "value": {
                    "description": "The [lexical form](https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form).",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Node": {
        "title": "Node",
        "description": "Represents either an IRI (named node) or a blank node.",
        "oneOf": [
          {
            "title": "NamedNode",
            "description": "An RDF [IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-iri).",
            "type": "object",
            "required": [
              "named_node"
            ],
            "properties": {
              "named_node": {
                "$ref": "#/definitions/IRI"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "BlankNode",
            "description": "An RDF [blank node](https://www.w3.org/TR/rdf11-concepts/#dfn-blank-node).",
            "type": "object",
            "required": [
              "blank_node"
            ],
            "properties": {
              "blank_node": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Prefix": {
        "title": "Prefix",
        "description": "Represents a prefix, i.e. a shortcut for a namespace used in a query.",
        "type": "object",
        "required": [
          "namespace",
          "prefix"
        ],
        "properties": {
          "namespace": {
            "description": "The namespace associated with the prefix.",
            "type": "string"
          },
          "prefix": {
            "description": "The prefix.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "SimpleWhereCondition": {
        "title": "SimpleWhereCondition",
        "description": "Represents a simple condition in a [WhereCondition].",
        "oneOf": [
          {
            "title": "TriplePattern",
            "description": "Represents a triple pattern, i.e. a condition on a triple based on its subject, predicate and object.",
            "type": "object",
            "required": [
              "triple_pattern"
            ],
            "properties": {
              "triple_pattern": {
                "$ref": "#/definitions/TriplePattern"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "TripleDeleteTemplate": {
        "title": "TripleDeleteTemplate",
        "description": "Represents a triple template to be deleted.",
        "type": "object",
        "required": [
          "object",
          "predicate",
          "subject"
        ],
        "properties": {
          "object": {
            "description": "The object of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNodeOrLiteral"
              }
            ]
          },
          "predicate": {
            "description": "The predicate of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          },
          "subject": {
            "description": "The subject of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TriplePattern": {
        "title": "TriplePattern",
        "description": "Represents a triple pattern in a [SimpleWhereCondition].",
        "type": "object",
        "required": [
          "object",
          "predicate",
          "subject"
        ],
        "properties": {
          "object": {
            "description": "The object of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNodeOrLiteral"
              }
            ]
          },
          "predicate": {
            "description": "The predicate of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          },
          "subject": {
            "description": "The subject of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNode"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "VarOrNamedNode": {
        "title": "VarOrNamedNode {",
        "description": "Represents either a variable or a named node (IRI).",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "NamedNode",
            "description": "An RDF [IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-iri).",
            "type": "object",
            "required": [
              "named_node"
            ],
            "properties": {
              "named_node": {
                "$ref": "#/definitions/IRI"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "VarOrNamedNodeOrLiteral": {
        "title": "VarOrNamedNodeOrLiteral",
        "description": "Represents either a variable, a named node or a literal.",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "NamedNode",
            "description": "An RDF [IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-iri).",
            "type": "object",
            "required": [
              "named_node"
            ],
            "properties": {
              "named_node": {
                "$ref": "#/definitions/IRI"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Literal",
            "description": "An RDF [literal](https://www.w3.org/TR/rdf11-concepts/#dfn-literal), i.e. a simple literal, a language-tagged string or a typed value.",
            "type": "object",
            "required": [
              "literal"
            ],
            "properties": {
              "literal": {
                "$ref": "#/definitions/Literal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "VarOrNode": {
        "title": "VarOrNode",
        "description": "Represents either a variable or a node.",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Node",
            "description": "A node, i.e. an IRI or a blank node.",
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/Node"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "VarOrNodeOrLiteral": {
        "title": "VarOrNodeOrLiteral",
        "description": "Represents either a variable, a node or a literal.",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Node",
            "description": "A node, i.e. an IRI or a blank node.",
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/Node"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Literal",
            "description": "An RDF [literal](https://www.w3.org/TR/rdf11-concepts/#dfn-literal), i.e. a simple literal, a language-tagged string or a typed value.",
            "type": "object",
            "required": [
              "literal"
            ],
            "properties": {
              "literal": {
                "$ref": "#/definitions/Literal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "WhereCondition": {
        "title": "WhereCondition",
        "description": "Represents a condition in a [WhereClause].",
        "oneOf": [
          {
            "title": "Simple",
            "description": "Represents a simple condition.",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "$ref": "#/definitions/SimpleWhereCondition"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Query messages",
    "oneOf": [
      {
        "title": "Store",
        "description": "Returns information about the triple store.",
        "type": "object",
        "required": [
          "store"
        ],
        "properties": {
          "store": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "title": "Select",
        "description": "Returns the resources matching the criteria defined by the provided query.",
        "type": "object",
        "required": [
          "select"
        ],
        "properties": {
          "select": {
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "query": {
                "description": "The query to execute.",
                "allOf": [
                  {
                    "$ref": "#/definitions/SelectQuery"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "title": "Describe",
        "description": "Returns a description of the resource identified by the provided IRI as a set of RDF triples serialized in the provided format.",
        "type": "object",
        "required": [
          "describe"
        ],
        "properties": {
          "describe": {
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "format": {
                "description": "The format in which the triples are serialized. If not provided, the default format is [Turtle](https://www.w3.org/TR/turtle/) format.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/DataFormat"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "query": {
                "description": "The query to execute.",
                "allOf": [
                  {
                    "$ref": "#/definitions/DescribeQuery"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "title": "Construct",
        "description": "Returns the resources matching the criteria defined by the provided query as a set of RDF triples serialized in the provided format.",
        "type": "object",
        "required": [
          "construct"
        ],
        "properties": {
          "construct": {
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "format": {
                "description": "The format in which the triples are serialized. If not provided, the default format is [Turtle](https://www.w3.org/TR/turtle/) format.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/DataFormat"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "query": {
                "description": "The query to execute.",
                "allOf": [
                  {
                    "$ref": "#/definitions/ConstructQuery"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ConstructQuery": {
        "title": "ConstructQuery",
        "description": "Represents a CONSTRUCT query over the triple store, allowing to retrieve a set of triples serialized in a specific format.",
        "type": "object",
        "required": [
          "construct",
          "prefixes",
          "where"
        ],
        "properties": {
          "construct": {
            "description": "The triples to construct. If nothing is provided, the patterns from the `where` clause are used for construction.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/TripleConstructTemplate"
            }
          },
          "prefixes": {
            "description": "The prefixes used in the query.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Prefix"
            }
          },
          "where": {
            "description": "The WHERE clause. This clause is used to specify the triples to construct using variable bindings.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/WhereCondition"
            }
          }
        },
        "additionalProperties": false
      },
      "DataFormat": {
        "title": "DataFormat",
        "description": "Represents the format in which the data are serialized, for example when returned by a query or when inserted in the store.",
        "oneOf": [
          {
            "title": "RDF XML",
            "description": "Output in [RDF/XML](https://www.w3.org/TR/rdf-syntax-grammar/) format.",
            "type": "string",
            "enum": [
              "rdf_xml"
            ]
          },
          {
            "title": "Turtle",
            "description": "Output in [Turtle](https://www.w3.org/TR/turtle/) format.",
            "type": "string",
            "enum": [
              "turtle"
            ]
          },
          {
            "title": "N-Triples",
            "description": "Output in [N-Triples](https://www.w3.org/TR/n-triples/) format.",
            "type": "string",
            "enum": [
              "n_triples"
            ]
          },
          {
            "title": "N-Quads",
            "description": "Output in [N-Quads](https://www.w3.org/TR/n-quads/) format.",
            "type": "string",
            "enum": [
              "n_quads"
            ]
          }
        ]
      },
      "DescribeQuery": {
        "title": "DescribeQuery",
        "description": "Represents a DESCRIBE query over the triple store, allowing to retrieve a description of a resource as a set of triples serialized in a specific format.",
        "type": "object",
        "required": [
          "prefixes",
          "resource",
          "where"
        ],
        "properties": {
          "prefixes": {
            "description": "The prefixes used in the query.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Prefix"
            }
          },
          "resource": {
            "description": "The resource to describe given as a variable or a node.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          },
          "where": {
            "description": "The WHERE clause. This clause is used to specify the resource identifier to describe using variable bindings.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/WhereCondition"
            }
          }
        },
        "additionalProperties": false
      },
      "IRI": {
        "title": "IRI",
        "description": "Represents an IRI.",
        "oneOf": [
          {
            "title": "Prefixed",
            "description": "An IRI prefixed with a prefix. The prefixed IRI is expanded to a full IRI using the prefix definition specified in the query. For example, the prefixed IRI `rdf:type` is expanded to `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`.",
            "type": "object",
            "required": [
              "prefixed"
            ],
            "properties": {
              "prefixed": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Full",
            "description": "A full IRI.",
            "type": "object",
            "required": [
              "full"
            ],
            "properties": {
              "full": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Literal": {
        "title": "Literal",
        "description": "An RDF [literal](https://www.w3.org/TR/rdf11-concepts/#dfn-literal).",
        "oneOf": [
          {
            "title": "Simple",
            "description": "A [simple literal](https://www.w3.org/TR/rdf11-concepts/#dfn-simple-literal) without datatype or language form.",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "LanguageTaggedString",
            "description": "A [language-tagged string](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)",
            "type": "object",
            "required": [
              "language_tagged_string"
            ],
            "properties": {
              "language_tagged_string": {
                "type": "object",
                "required": [
                  "language",
                  "value"
                ],
                "properties": {
                  "language": {
                    "description": "The [language tag](https://www.w3.org/TR/rdf11-concepts/#dfn-language-tag).",
                    "type": "string"
                  },
                  "value": {
                    "description": "The [lexical form](https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form).",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "title": "TypedValue",
            "description": "A value with a datatype.",
            "type": "object",
            "required": [
              "typed_value"
            ],
            "properties": {
              "typed_value": {
                "type": "object",
                "required": [
                  "datatype",
                  "value"
                ],
                "properties": {
                  "datatype": {
                    "description": "The [datatype IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri).",
                    "allOf": [
                      {
                        "$ref": "#/definitions/IRI"
                      }
                    ]
                  },
                  "value": {
                    "description": "The [lexical form](https://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form).",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Node": {
        "title": "Node",
        "description": "Represents either an IRI (named node) or a blank node.",
        "oneOf": [
          {
            "title": "NamedNode",
            "description": "An RDF [IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-iri).",
            "type": "object",
            "required": [
              "named_node"
            ],
            "properties": {
              "named_node": {
                "$ref": "#/definitions/IRI"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "BlankNode",
            "description": "An RDF [blank node](https://www.w3.org/TR/rdf11-concepts/#dfn-blank-node).",
            "type": "object",
            "required": [
              "blank_node"
            ],
            "properties": {
              "blank_node": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Prefix": {
        "title": "Prefix",
        "description": "Represents a prefix, i.e. a shortcut for a namespace used in a query.",
        "type": "object",
        "required": [
          "namespace",
          "prefix"
        ],
        "properties": {
          "namespace": {
            "description": "The namespace associated with the prefix.",
            "type": "string"
          },
          "prefix": {
            "description": "The prefix.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "SelectItem": {
        "title": "SelectItem",
        "description": "Represents an item to select in a [SelectQuery].",
        "oneOf": [
          {
            "title": "Variable",
            "description": "Represents a variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "SelectQuery": {
        "title": "SelectQuery",
        "description": "Represents a SELECT query over the triple store, allowing to select variables to return and to filter the results.",
        "type": "object",
        "required": [
          "prefixes",
          "select",
          "where"
        ],
        "properties": {
          "limit": {
            "description": "The maximum number of results to return. If `None`, there is no limit. Note: the value of the limit cannot exceed the maximum query limit defined in the store limitations.",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0
          },
          "prefixes": {
            "description": "The prefixes used in the query.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Prefix"
            }
          },
          "select": {
            "description": "The items to select. Note: the number of items to select cannot exceed the maximum query variable count defined in the store limitations.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/SelectItem"
            }
          },
          "where": {
            "description": "The WHERE clause. If `None`, there is no WHERE clause, i.e. all triples are returned without filtering.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/WhereCondition"
            }
          }
        },
        "additionalProperties": false
      },
      "SimpleWhereCondition": {
        "title": "SimpleWhereCondition",
        "description": "Represents a simple condition in a [WhereCondition].",
        "oneOf": [
          {
            "title": "TriplePattern",
            "description": "Represents a triple pattern, i.e. a condition on a triple based on its subject, predicate and object.",
            "type": "object",
            "required": [
              "triple_pattern"
            ],
            "properties": {
              "triple_pattern": {
                "$ref": "#/definitions/TriplePattern"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "TripleConstructTemplate": {
        "title": "TripleConstructTemplate",
        "description": "Represents a triple template to be forged for a construct query.",
        "type": "object",
        "required": [
          "object",
          "predicate",
          "subject"
        ],
        "properties": {
          "object": {
            "description": "The object of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNodeOrLiteral"
              }
            ]
          },
          "predicate": {
            "description": "The predicate of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          },
          "subject": {
            "description": "The subject of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNode"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TriplePattern": {
        "title": "TriplePattern",
        "description": "Represents a triple pattern in a [SimpleWhereCondition].",
        "type": "object",
        "required": [
          "object",
          "predicate",
          "subject"
        ],
        "properties": {
          "object": {
            "description": "The object of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNodeOrLiteral"
              }
            ]
          },
          "predicate": {
            "description": "The predicate of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNamedNode"
              }
            ]
          },
          "subject": {
            "description": "The subject of the triple pattern.",
            "allOf": [
              {
                "$ref": "#/definitions/VarOrNode"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "VarOrNamedNode": {
        "title": "VarOrNamedNode {",
        "description": "Represents either a variable or a named node (IRI).",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "NamedNode",
            "description": "An RDF [IRI](https://www.w3.org/TR/rdf11-concepts/#dfn-iri).",
            "type": "object",
            "required": [
              "named_node"
            ],
            "properties": {
              "named_node": {
                "$ref": "#/definitions/IRI"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "VarOrNode": {
        "title": "VarOrNode",
        "description": "Represents either a variable or a node.",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Node",
            "description": "A node, i.e. an IRI or a blank node.",
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/Node"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "VarOrNodeOrLiteral": {
        "title": "VarOrNodeOrLiteral",
        "description": "Represents either a variable, a node or a literal.",
        "oneOf": [
          {
            "title": "Variable",
            "description": "A variable.",
            "type": "object",
            "required": [
              "variable"
            ],
            "properties": {
              "variable": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Node",
            "description": "A node, i.e. an IRI or a blank node.",
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/Node"
              }
            },
            "additionalProperties": false
          },
          {
            "title": "Literal",
            "description": "An RDF [literal](https://www.w3.org/TR/rdf11-concepts/#dfn-literal), i.e. a simple literal, a language-tagged string or a typed value.",
            "type": "object",
            "required": [
              "literal"
            ],
            "properties": {
              "literal": {
                "$ref": "#/definitions/Literal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "WhereCondition": {
        "title": "WhereCondition",
        "description": "Represents a condition in a [WhereClause].",
        "oneOf": [
          {
            "title": "Simple",
            "description": "Represents a simple condition.",
            "type": "object",
            "required": [
              "simple"
            ],
            "properties": {
              "simple": {
                "$ref": "#/definitions/SimpleWhereCondition"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "construct": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConstructResponse",
      "description": "Represents the response of a [QueryMsg::Construct] query.",
      "type": "object",
      "required": [
        "data",
        "format"
      ],
      "properties": {
        "data": {
          "description": "The data serialized in the specified format.",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "format": {
          "description": "The format of the data.",
          "allOf": [
            {
              "$ref": "#/definitions/DataFormat"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "DataFormat": {
          "title": "DataFormat",
          "description": "Represents the format in which the data are serialized, for example when returned by a query or when inserted in the store.",
          "oneOf": [
            {
              "title": "RDF XML",
              "description": "Output in [RDF/XML](https://www.w3.org/TR/rdf-syntax-grammar/) format.",
              "type": "string",
              "enum": [
                "rdf_xml"
              ]
            },
            {
              "title": "Turtle",
              "description": "Output in [Turtle](https://www.w3.org/TR/turtle/) format.",
              "type": "string",
              "enum": [
                "turtle"
              ]
            },
            {
              "title": "N-Triples",
              "description": "Output in [N-Triples](https://www.w3.org/TR/n-triples/) format.",
              "type": "string",
              "enum": [
                "n_triples"
              ]
            },
            {
              "title": "N-Quads",
              "description": "Output in [N-Quads](https://www.w3.org/TR/n-quads/) format.",
              "type": "string",
              "enum": [
                "n_quads"
              ]
            }
          ]
        }
      }
    },
    "describe": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DescribeResponse",
      "description": "Represents the response of a [QueryMsg::Describe] query.",
      "type": "object",
      "required": [
        "data",
        "format"
      ],
      "properties": {
        "data": {
          "description": "The data serialized in the specified format.",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "format": {
          "description": "The format of the data.",
          "allOf": [
            {
              "$ref": "#/definitions/DataFormat"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "DataFormat": {
          "title": "DataFormat",
          "description": "Represents the format in which the data are serialized, for example when returned by a query or when inserted in the store.",
          "oneOf": [
            {
              "title": "RDF XML",
              "description": "Output in [RDF/XML](https://www.w3.org/TR/rdf-syntax-grammar/) format.",
              "type": "string",
              "enum": [
                "rdf_xml"
              ]
            },
            {
              "title": "Turtle",
              "description": "Output in [Turtle](https://www.w3.org/TR/turtle/) format.",
              "type": "string",
              "enum": [
                "turtle"
              ]
            },
            {
              "title": "N-Triples",
              "description": "Output in [N-Triples](https://www.w3.org/TR/n-triples/) format.",
              "type": "string",
              "enum": [
                "n_triples"
              ]
            },
            {
              "title": "N-Quads",
              "description": "Output in [N-Quads](https://www.w3.org/TR/n-quads/) format.",
              "type": "string",
              "enum": [
                "n_quads"
              ]
            }
          ]
        }
      }
    },
    "select": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SelectResponse",
      "description": "Represents the response of a [QueryMsg::Select] query.",
      "type": "object",
      "required": [
        "head",
        "results"
      ],
      "properties": {
        "head": {
          "description": "The head of the response, i.e. the set of variables mentioned in the results.",
          "allOf": [
            {
              "$ref": "#/definitions/Head"
            }
          ]
        },
        "results": {
          "description": "The results of the select query.",
          "allOf": [
            {
              "$ref": "#/definitions/Results"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Head": {
          "title": "Head",
          "description": "Represents the head of a [SelectResponse].",
          "type": "object",
          "required": [
            "vars"
          ],
          "properties": {
            "vars": {
              "description": "The variables selected in the query.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "IRI": {
          "title": "IRI",
          "description": "Represents an IRI.",
          "oneOf": [
            {
              "title": "Prefixed",
              "description": "An IRI prefixed with a prefix. The prefixed IRI is expanded to a full IRI using the prefix definition specified in the query. For example, the prefixed IRI `rdf:type` is expanded to `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`.",
              "type": "object",
              "required": [
                "prefixed"
              ],
              "properties": {
                "prefixed": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            {
              "title": "Full",
              "description": "A full IRI.",
              "type": "object",
              "required": [
                "full"
              ],
              "properties": {
                "full": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Results": {
          "title": "Results",
          "description": "Represents the results of a [SelectResponse].",
          "type": "object",
          "required": [
            "bindings"
          ],
          "properties": {
            "bindings": {
              "description": "The bindings of the results.",
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": false
              }
            }
          },
          "additionalProperties": false
        },
        "Value": {
          "title": "Value",
          "oneOf": [
            {
              "title": "URI",
              "description": "Represents an IRI.",
              "type": "object",
              "required": [
                "type",
                "value"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "uri"
                  ]
                },
                "value": {
                  "description": "The value of the IRI.",
                  "allOf": [
                    {
                      "$ref": "#/definitions/IRI"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            {
              "title": "Literal",
              "description": "Represents a literal S with optional language tag L or datatype IRI D.",
              "type": "object",
              "required": [
                "type",
                "value"
              ],
              "properties": {
                "datatype": {
                  "description": "The datatype of the literal.",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/IRI"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "literal"
                  ]
                },
                "value": {
                  "description": "The value of the literal.",
                  "type": "string"
                },
                "xml:lang": {
                  "description": "The language tag of the literal.",
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "additionalProperties": false
            },
            {
              "title": "BlankNode",
              "description": "Represents a blank node.",
              "type": "object",
              "required": [
                "type",
                "value"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "blank_node"
                  ]
                },
                "value": {
                  "description": "The identifier of the blank node.",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "store": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StoreResponse",
      "description": "Contains information related to triple store.",
      "type": "object",
      "required": [
        "limits",
        "owner",
        "stat"
      ],
      "properties": {
        "limits": {
          "description": "The store limits.",
          "allOf": [
            {
              "$ref": "#/definitions/StoreLimits"
            }
          ]
        },
        "owner": {
          "description": "The store owner.",
          "type": "string"
        },
        "stat": {
          "description": "The store current usage.",
          "allOf": [
            {
              "$ref": "#/definitions/StoreStat"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "StoreLimits": {
          "title": "StoreLimits",
          "description": "Contains limitations regarding store usages.",
          "type": "object",
          "required": [
            "max_byte_size",
            "max_insert_data_byte_size",
            "max_insert_data_triple_count",
            "max_query_limit",
            "max_query_variable_count",
            "max_triple_byte_size",
            "max_triple_count"
          ],
          "properties": {
            "max_byte_size": {
              "description": "The maximum number of bytes the store can contain. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "max_insert_data_byte_size": {
              "description": "The maximum number of bytes an insert data query can contain.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "max_insert_data_triple_count": {
              "description": "The maximum number of triples an insert data query can contain (after parsing).",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "max_query_limit": {
              "description": "The maximum limit of a query, i.e. the maximum number of triples returned by a select query.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "max_query_variable_count": {
              "description": "The maximum number of variables a query can select.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "max_triple_byte_size": {
              "description": "The maximum number of bytes the store can contain for a single triple. The size of a triple is counted as the sum of the size of its subject, predicate and object, including the size of data types and language tags if any. The limit is used to prevent storing very large triples, especially literals.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "max_triple_count": {
              "description": "The maximum number of triples the store can contain.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "StoreStat": {
          "title": "StoreStat",
          "description": "Contains usage information about the triple store.",
          "type": "object",
          "required": [
            "byte_size",
            "namespace_count",
            "triple_count"
          ],
          "properties": {
            "byte_size": {
              "description": "The total triple size in the store, in bytes.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "namespace_count": {
              "description": "The total number of IRI namespace present in the store.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "triple_count": {
              "description": "The total number of triple present in the store.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  },
  "description": "# Cognitarium\n\nA [CosmWasm](https://cosmwasm.com/) Smart Contract which enables the storage and querying of Semantic data using [RDF (Resource Description Framework)](https://en.wikipedia.org/wiki/Resource_Description_Framework), which represents information as semantic triples.\n\n## Purpose\n\nThe Smart Contract operates as a [semantic database](https://en.wikipedia.org/wiki/Triplestore), adept at storing and fetching [RDF triples](https://en.wikipedia.org/wiki/Semantic_triple) via semantic queries. It can be deployed on any blockchain within the [Cosmos blockchains](https://cosmos.network/) network, utilizing the [CosmWasm](https://cosmwasm.com/) framework.\n\nThe key features of the contract include:\n\n**Insertion of RDF Triples:**\nThis functionality enables the insertion of new data in the form of [RDF triples](https://en.wikipedia.org/wiki/Semantic_triple) onto the blockchain, ensuring secure and tamper-proof storage. The Smart Contract supports inserting these triples in various serialization formats including [RDF/XML](https://en.wikipedia.org/wiki/RDF/XML), [Turtle](https://www.w3.org/TR/turtle/), [N-Triples](https://www.w3.org/TR/n-triples/) and [N-Quads](https://www.w3.org/TR/n-quads/).\n\n**Removal of RDF Triples:**\nThis functionality enables the selective deletion of RDF triples from the on-chain store. Users can specify patterns or criteria that identify the triples to be removed, ensuring precise and targeted removal of data.\n\n**Querying of RDF Triples:**\nThe Smart Contract provides powerful on-chain querying capabilities, allowing users to retrieve specific RDF triples stored on the blockchain. This is done using a variation of [SPARQL](https://www.w3.org/TR/sparql11-query/), a specialized query language designed for retrieving and manipulating data stored in RDF format. Users can specify their search criteria in the query, and the Smart Contract will return the matching RDF triples, directly accessing the on-chain data. This feature supports various serialization formats for the output, such as Turtle, N-Triples, N-Quads, and RDF/XML, offering flexibility in how the retrieved data is presented and used.\n\n**Policies of the Store:**\nThe Smart Contract includes a straightforward yet effective policies functionality to manage the capacity and usage of the on-chain storage effectively. These policies ensure efficient operation and prevent misuse or overuse of the Smart Contract. For instance:\n\n- Maximum Triples: Caps the total number of RDF triples the store can hold, preventing database overload.\n- Storage Size Limit: Sets an upper bound on the store's data size in bytes, managing blockchain resource use.\n- Query Size Limit: Restricts the size or complexity of queries to maintain fast and reliable data retrieval.\n- Insert Data Limit: Limits the size of data (in bytes) that can be added in a single transaction, ensuring smooth and efficient data insertion.\n\n## Rationale\n\nThe data preserved in the blockchain holds significant value due to its derivation from a distributed consensus, rendering it a reliable source for decision-making, applicable to both on-chain and off-chain scenarios.\n\nTo effectively utilize this data, it's essential to adopt representation models that cater to diverse requirements. The Smart Contract Cognitarium provides such a model, facilitating the depiction of intricate and evolving semantic connections within a highly interconnected dataset. This approach transforms the data into a Knowledge Graph, enabling an accurate portrayal of existing facts and fostering the generation of new insights.\n\n## Play\n\n### Model your data with RDF\n\n[RDF](https://www.w3.org/RDF/) encodes information in triple structures. The basic structure of an RDF triple is `subject-predicate-object`, much like a simple sentence in the English language.\n\n1. **Subject**: The subject is the entity or resource the statement is about. It's typically a URI ([Uniform Resource Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)) which uniquely identifies a resource.\n2. **Predicate**: The predicate (also called a property) is a specific aspect, characteristic, attribute, or relation that describes the subject. It's also typically a URI.\n3. **Object**: The object is the value of the attribute defined by the predicate for the subject. It can be a URI or a literal (such as a string or a number) and may also include additional information such as a language tag or a datatype.\n\nIn RDF, **prefixes** are used as a shorthand notation for long URIs to make the data more readable and less verbose. They're similar to namespaces in programming languages. For instance, instead of writing `http://www.w3.org/2001/XMLSchema#integer`, you could declare a prefix `xsd` to represent the `http://www.w3.org/2001/XMLSchema#` URI and then use `xsd:integer`.\n\n[Turtle (Terse RDF Triple Language)](https://www.w3.org/TR/turtle/) is a syntax that allows RDF to be completely written in a compact and natural text form, with abbreviations for common usage patterns and datatypes.\n\nHere's an RDF triple written in Turtle format (`.ttl` file):\n\n```turtle\n@prefix ex: <http://example.com/stuff/1.0/> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\nex:Alice ex:hasAge \"30\"^^xsd:integer .\n```\n\nIn this example:\n\n- **`ex:Alice`** is the subject (using `ex` as a prefix for the `http://example.com/stuff/1.0/` URI).\n- **`ex:hasAge`** is the predicate.\n- **`\"30\"^^xsd:integer`** is the object, a literal of datatype integer (using **`xsd`** as a prefix for the XML Schema Datatype namespace).\n\nIn the Turtle syntax, the semicolon (**`;`**) is used as a shorthand to reduce verbosity when multiple predicates and objects have the same subject. It allows you to write multiple predicates and objects for the same subject without having to repeat the subject.\nThe comma (**`,`**) is used as a shorthand for reducing verbosity when the same subject and predicate have multiple objects.\n\nSuppose we want to express that Alice is 30 years old person, and her email is `alice@example.com`:\n\n```turtle\n@prefix ex: <http://example.com/stuff/1.0/> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\nex:Alice a <http://www.w3.org/2002/07/owl#Person> ;\n         ex:hasAge \"30\"^^xsd:integer ;\n         ex:hasEmail \"alice@example.com\" .\n```\n\n:::tip\nThe lowercase \"a\" is a special abbreviation for the RDF type property, which states that a resource is an instance of a particular class. This is essentially equivalent to **`<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>`**, and it's used to indicate the type of a resource.\n:::\n\nThe same RDF triple can be expressed in RDF/XML format (`.rdf.xml` file):\n\n```xml\n<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n         xmlns:ex=\"http://example.com/stuff/1.0/\"\n         xmlns:xsd=\"http://www.w3.org/2001/XMLSchema#\">\n  <rdf:Description rdf:about=\"http://example.com/stuff/1.0/Alice\">\n    <rdf:type rdf:resource=\"http://www.w3.org/2002/07/owl#Person\"/>\n    <ex:hasAge rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\">30</ex:hasAge>\n    <ex:hasEmail>alice@example.com</ex:hasEmail>    \n  </rdf:Description>\n</rdf:RDF>\n```\n\n### Instantiate the Smart Contract\n\nLet's initiate a new instance of Smart Contract and input some RDF triples into it. The `axone-cognitarium` can be set up in the following manner. Please consult the schema for additional details regarding configuration settings.\n\n```bash\naxoned tx wasm instantiate $CODE_ID \\\n    --from $ADDR \\\n    --label \"my-rdf-storage\" \\\n    --admin $ADMIN_ADDR \\\n    --gas 1000000 \\\n    '{}'\n```\n\n:::tip\nYou can provide some limitation parameters to restrict usage for both execute and query messages. For instance, you can set a maximum number of triples that can be stored in the smart contract, or a maximum size of data that can be inserted in a single transaction.\n\nThe default values are:\n\n```json\n{ \n  \"limits\": {\n\t\t  \"max_byte_size\": \"340282366920938463463374607431768211455\",\n\t\t  \"max_insert_data_byte_size\": \"340282366920938463463374607431768211455\",\n\t\t  \"max_insert_data_triple_count\": \"340282366920938463463374607431768211455\",\n\t\t  \"max_query_limit\": 30,\n\t\t  \"max_query_variable_count\": 30,\n\t\t  \"max_triple_byte_size\": \"340282366920938463463374607431768211455\",\n\t\t  \"max_triple_count\": \"340282366920938463463374607431768211455\"\n\t}\n}\n```\n\n:::\n\n### Insert RDF triples\n\nTo insert RDF triples, you need to send an `InsertData` message through the `cognitarium` smart contract you've already instantiated. For this operation, your inputs should include the data of the triples, encoded in [base64](https://en.wikipedia.org/wiki/Base64), as well as the format. The format options available are:\n\n- `turtle` (default)\n- `rdf_xml`\n- `n_triples`\n- `n_quads`\n\nLet's consider the following example of data in Turtle format, contained within a file named `data.ttl`. It describes a small network of people and their relationships, such as name, title, and whom they know.\n\n```turtle\n@prefix : <http://example.org/> .\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix schema: <http://schema.org/> .\n\n:alice a foaf:Person ;\n  foaf:name \"Alice\" ;\n  foaf:knows :bob ;\n  schema:email \"alice@example.org\" .\n\n:bob a foaf:Person ;\n  foaf:name \"Bob\" ;\n  foaf:knows :alice, :carol ;\n  schema:jobTitle \"Software Developer\" .\n\n:carol a foaf:Person ;\n  foaf:name \"Carol\" ;\n  schema:jobTitle \"Data Scientist\" ;\n  foaf:knows :bob .\n```\n\nYou can insert this data into the `cognitarium` smart contract with the following command:\n\n```bash\naxoned tx wasm execute $CONTRACT_ADDR \\\n    --from axone1cu9wzlcyyxpek20jaqfwzu3llzjgx34cqf94yj \\\n    --gas 10000000 \\\n    \"{\\\"insert_data\\\":{\\\"format\\\": \\\"turtle\\\", \\\"data\\\": \\\"$(cat data.ttl | base64 | tr -d '\\n\\r')\\\"}}\"\n```\n\nWith the transaction hash we can query the number of triples inserted:\n\n```bash\naxoned query tx $TX_HASH -ojson | \n    jq -r '.events[] | select(.type == \"wasm\") | .attributes[] | select(.key == \"triple_count\") | .value'\n```\n\n### Query RDF triples\n\nNow that we've populated the axone-cognitarium with several triples, let's explore how to retrieve this data. We can utilize the Select query message for this purpose. If you're familiar with [SPARQL](https://www.w3.org/TR/rdf-sparql-query/), you'll find the process quite intuitive.\n\nA `select` query on a `cognitarium` instance enables you to fetch and filter the data. The `select.query` JSON should contain the following:\n\n- `prefixes` array: to declare a `prefix` and its related `namespace`\n- `limit`: the number of elements to return\n- `where`: filters and variable declarations\n- `select` array: all `variable` names you declared in `where` you want to get\n\n`where` should be an array of elements specifying triple filterings. You have to specify `subject`, `predicate` and `object` as a `variable`, or, alternatively, a `prefixed` or `full` `named_node`.\n\n`object` can also be a `simple` `literal`.\n\nThe following query will select all the triples `subject`, `predicate` and `object` from the store:\n\n```json\n{\n    \"select\": {\n        \"query\": {\n            \"prefixes\": [],\n            \"select\": [\n                {\n                    \"variable\": \"subject\"\n                },\n                {\n                    \"variable\": \"predicate\"\n                },\n                {\n                    \"variable\": \"object\"\n                }\n            ],\n            \"where\": [\n                {\n                    \"simple\": {\n                        \"triple_pattern\": {\n                            \"subject\": {\n                                \"variable\": \"subject\"\n                            },\n                            \"predicate\": {\n                                \"variable\": \"predicate\"\n                            },\n                            \"object\": {\n                                \"variable\": \"object\"\n                            }\n                        }\n                    }\n                }\n            ],\n            \"limit\": null\n        }\n    }\n}\n```\n\nIt's semantically equivalent to the following SPARQL query:\n\n```sparql\nSELECT ?subject ?predicate ?object\nWHERE {\n    ?subject ?predicate ?object\n}\n```\n\nThis query can be executed on the cognitarium smart contract using the command below:\n\n```bash\naxoned query wasm contract-state smart $CONTRACT_ADDR \\\n    '{\"select\":{\"query\":{\"prefixes\":[],\"select\":[{\"variable\":\"subject\"},{\"variable\":\"predicate\"},{\"variable\":\"object\"}],\"where\":[{\"simple\":{\"triple_pattern\":{\"subject\":{\"variable\":\"subject\"},\"predicate\":{\"variable\":\"predicate\"},\"object\":{\"variable\":\"object\"}}}}],\"limit\":null}}}'\n```\n\nNow, let's try something more interresting. Let's retrieve the names of people and their job titles, but only for those who know at least one other person in the network. This query introduces filtering based on relationships.\n\nHere's the query:\n\n```json\n{\n    \"select\": {\n        \"query\": {\n            \"prefixes\": [\n                { \"foaf\": \"http://xmlns.com/foaf/0.1/\" },\n                { \"schema\": \"http://schema.org/\" }\n            ],\n            \"select\": [\n                {\n                    \"variable\": \"personName\"\n                },\n                {\n                    \"variable\": \"jobTitle\"\n                }\n            ],\n            \"where\": [\n                {\n                    \"simple\": {\n                        \"triple_pattern\": {\n                            \"subject\": {\n                                \"variable\": \"person\"\n                            },\n                            \"predicate\": {\n                              \"node\": {\n                                \"named_node\": {\n                                  \"full\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"\n                                }\n                              }\n                            },\n                            \"object\": {\n                                \"node\": {\n                                    \"named_node\": {\n                                        \"prefixed\": \"foaf:Person\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                {\n                    \"simple\": {\n                        \"triple_pattern\": {\n                            \"subject\": {\n                                \"variable\": \"person\"\n                            },\n                            \"predicate\": {\n                                \"node\": {\n                                    \"named_node\": {\n                                        \"prefixed\": \"foaf:Name\"\n                                    }\n                                }\n                            },\n                            \"object\": {\n                                \"variable\": \"personName\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"simple\": {\n                        \"triple_pattern\": {\n                            \"subject\": {\n                                \"variable\": \"person\"\n                            },\n                            \"predicate\": {\n                                \"node\": {\n                                    \"named_node\": {\n                                        \"prefixed\": \"schema:jobTitle\"\n                                    }\n                                }\n                            },\n                            \"object\": {\n                                \"variable\": \"jobTitle\"\n                            }\n                        }\n                    }\n                },\n                {\n                    \"simple\": {\n                        \"triple_pattern\": {\n                            \"subject\": {\n                                \"variable\": \"person\"\n                            },\n                            \"predicate\": {\n                                \"node\": {\n                                    \"named_node\": {\n                                        \"prefixed\": \"foaf:knows\"\n                                    }\n                                }\n                            },\n                            \"object\": {\n                                \"variable\": \"knownPerson\"\n                            }\n                        }\n                    }\n                }\n            ],\n            \"limit\": null\n        }\n    }\n}\n```\n\nIt's semantically equivalent to the following SPARQL query:\n\n```sparql\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX schema: <http://schema.org/>\n\nSELECT ?personName ?jobTitle\nWHERE {\n  ?person a foaf:Person .\n  ?person foaf:name ?personName .\n  ?person schema:jobTitle ?jobTitle .\n  ?person foaf:knows ?knownPerson .\n}\n```\n\nThis query can be executed on the cognitarium smart contract using the command below:\n\n```bash\naxoned query wasm contract-state smart $CONTRACT_ADDR \\\n    '{\"select\":{\"query\":{\"prefixes\":[{\"foaf\":\"http://xmlns.com/foaf/0.1/\"},{\"schema\":\"http://schema.org/\"}],\"select\":[{\"variable\":\"personName\"},{\"variable\":\"jobTitle\"}],\"where\":[{\"simple\":{\"triple_pattern\":{\"subject\":{\"variable\":\"person\"},\"predicate\":{\"node\":{\"named_node\":{\"full\":\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"}}},\"object\":{\"node\":{\"named_node\":{\"prefixed\":\"foaf:Person\"}}}}}},{\"simple\":{\"triple_pattern\":{\"subject\":{\"variable\":\"person\"},\"predicate\":{\"node\":{\"named_node\":{\"prefixed\":\"foaf:Name\"}}},\"object\":{\"variable\":\"personName\"}}}},{\"simple\":{\"triple_pattern\":{\"subject\":{\"variable\":\"person\"},\"predicate\":{\"node\":{\"named_node\":{\"prefixed\":\"schema:jobTitle\"}}},\"object\":{\"variable\":\"jobTitle\"}}}},{\"simple\":{\"triple_pattern\":{\"subject\":{\"variable\":\"person\"},\"predicate\":{\"node\":{\"named_node\":{\"prefixed\":\"foaf:knows\"}}},\"object\":{\"variable\":\"knownPerson\"}}}}],\"limit\":null}}}'\n```",
  "title": "axone-cognitarium"
}
